install.packages("swirl")
library(swirl)
swirl(resume.class=)
swirl()
library(swirl)
swirl()
bye()
q()
install.packages(KernSmooth)
library(KernSmooth)
library(datasets)
data(iris)
?iris
header(iris)
head(iris, n=10)
View(iris)
View(iris)
x<-iris.Species
View(iris)
View(iris)
View(iris)
View(iris)
data(iris)
head(iris, n=10)
indexes<-iris$Species=="virginica"
indexes
mean(iris$Sepal.Length[indexes])
apply(iris[, 1:4], 1, mean)
rowMeans(iris[, 1:4])
apply(iris, 2, mean)
apply(iris[, 1:4], 2, mean)
library(datasets)
data(mtcars)
?mtcars
head(mtcars,n=10)
?split
split(mtcars$mpg,mtcars$cyl)
?sapply
?tapply
?lapply
lapply(mtcars, mean)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$mpg,mtcars$cyl,mean)
x<-tapply(mtcars$mpg,mtcars$cyl,mean)
x[1]-x[3]
debug(ls)
ls
exit
q(0)
q()
library(datasets)
data(mtcars)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
library(datasets)
data(iris)
index<-
snthaoeu
index<-iris$Species=="virginica"
tapply(iris$Sepal.Length,iris$Species,mean)
colMeans(iris)
apply(iris, 1, mean)
apply(iris[, 1:4], 2, mean)
data(mtcars)
sapply(split(mtcars$mpg, mtcars$cyl), mean)
View(mtcars)
tapply(mtcars$hp,mtcars$cyl,mean)
x<-tapply(mtcars$hp,mtcars$cyl,mean)
x[3]-x[1]
install.packages("RXKCD")
m<-NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
get
setmean <- function(mean) m <<- mean
getmean <- function() m
thas<-5
thas
thas<-c(5,6)
thas
that<-78
data<-c(thas,that)
data
that<-(7,8)
that<-c(7,8)
data<-c(thas,that)
m <- NULL
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
numeric()
setwd("/home/scott/Documents/Rwork/RProgramming/ProgrammingAssignment2/")
getXKCD(which="552")
library("RXKCD")
getXKCD(which="552")
getXKCD(which="1")
getXKCD(which="2")
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
makeVector(c(1,2,3,4))
x$setmean
q<-makeVector(c(1,2,3,4))
q
q$get
things<-999
sing <- function(thing) sprintf("%d bottles of beer on the %s!", things, thing)
sing(wall)
sing("wall")
?sing
?sprintf
makeVector <- function(x = numeric()) {
m <- NULL
set <- function(y) {
x <<- y
m <<- NULL
}
get <- function() x
setmean <- function(mean) m <<- mean
getmean <- function() m
list(set = set, get = get,
setmean = setmean,
getmean = getmean)
}
cachemean <- function(x, ...) {
m <- x$getmean()
if(!is.null(m)) {
message("getting cached data")
return(m)
}
data <- x$get()
m <- mean(data, ...)
x$setmean(m)
m
}
a <- makeVector()
a$set(c(1,2,3,4,5,6,7))
a$get
p<-a$get
p
cachemean(a)
cachemean(a)
a$set(c(5,5,5,5,5,55))
cachemean(a)
cachemean(a)
a$get
a$get
a$get()
a <- makeVector()
a
class(a)
class(a$set)
class(a$get)
class(a$getmean)
class(a$setmean)
a$set(c(1,2,3,4,5,6,7))
a$get()
cachemean(a)
cachemean(a)
?as.matrix
solve(as.matrix(c(2,2,2,2)),2,2)
solve(as.matrix(c(2,2,2,2),2,2))
(as.matrix(c(2,2,2,2),2,2)
as.matrix(c(2,2,2,2),2,2)
as.matrix(c(2,2,2,2),nrow=2,ncol=2)
data<-c(2,2,2,2)
as.matrix(data,2,2)
?matrix
matrix(2,2,2,2,nrow=2,ncol=2)
matrix(c(2,2,2,2),nrow=2,ncol=2)
c(2,2;2,2)
data<-matrix(2,2,2,2,nrow=2,ncol=2)
data<-matrix(c(2,2,2,2),nrow=2,ncol=2)
data
makeCacheMatrix <- function(x = matrix()) {
I <- NULL
set <- function(y) {
x <<- y
I <<- NULL
}
get <- function() x
setinverse <- function(inverse) I <<- inverse
getinverse <- function() I
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
## Return a matrix that is the inverse of 'x'
I <- x$getinverse()
if(!is.null(I)) {
message("getting cached data")
return(I)
}
data <- x$get()
I <- solve(data, ...)
x$setinverse(I)
I
}
solve(data)
data<-matrix(c(2,2,2,1),nrow=2,ncol=2)
solve(data)
solve(data)%*%data
a<-makeCacheMatrix()
a
class(a)
class(a$set)
class(a$setinverse)
a$set(data)
a$get()
cacheSolve(a)
cacheSolve(a)
cacheSolve(a)
data<-matrix(c(21,2,2,1),nrow=2,ncol=2)
a<-makeCacheMatrix()
data<-matrix(c(2,2,2,1),nrow=2,ncol=2)
a$set(data)
a$get()
cacheSolve(a)
cacheSolve(a)
data<-matrix(c(21,2,2,1),nrow=2,ncol=2)
a$set(data)
cacheSolve(a)
makeCacheMatrix <- function(x = matrix()) {
#I holds the inverse
I <- NULL
#A function which (re)sets the matrix x, and (re)sets
#I to NULL for later calculation
set <- function(y) {
x <<- y
I <<- NULL
}
#a function to retrieve the matrix stored within x
get <- function() x
#functions to set and/or get the inverse
setinverse <- function(inverse) I <<- inverse
getinverse <- function() I
#return these four functions as a list
list(set = set, get = get,
setinverse = setinverse,
getinverse = getinverse)
}
cacheSolve <- function(x, ...) {
#grab whatever has been cached for I
I <- x$getinverse()
#if I was not empty, report that we grabbed the cached inverse and return
#that value
if(!is.null(I)) {
message("getting cached data")
return(I)
}
#otherwise, calculate inverse, cache it, and return that value
data <- x$get()
I <- solve(data, ...)
x$setinverse(I)
I
}
data<-matrix(c(2,2,2,1),nrow=2,ncol=2)
solve(data)
solve(data)%*%data
a<-makeCacheMatrix()
a
class(a)
class(a$set)
class(a$setinverse)
a$set(data)
a$get()
cacheSolve(a)
cacheSolve(a)
